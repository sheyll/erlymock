<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module em</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module em</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>   
The module name 'em' stands for 'Erly Mock'.
<p>Copyright Â© (C) 2011-2017 Sven Heyll</p>

<p><b>Behaviours:</b> <a href="gen_statem.html"><tt>gen_statem</tt></a>.</p>
<p><b>Authors:</b> Sven Heyll (<a href="mailto:sven.heyll@gmail.com"><tt>sven.heyll@gmail.com</tt></a>).</p>

<h2><a name="description">Description</a></h2><p>   
The module name 'em' stands for 'Erly Mock'.</p>
  
   <p>This mocking library works similar to Easymock.</p>
  
   <p>After a mock process is started by <a href="#new-0"><code>new/0</code></a> it can be programmed to
   expect function calls and to react to them in two ways: <ul><li>by returning
   a value</li><li>by executing an arbitrary function</li></ul> This is done
   with <a href="#strict-4"><code>strict/4</code></a>, <a href="#strict-5"><code>strict/5</code></a>, <a href="#stub-4"><code>stub/4</code></a>, <a href="#stub-5"><code>stub/5</code></a> </p>
  
   <p>Before the code under test is executed, the mock must be told
   that the programming phase is over by <a href="#replay-1"><code>replay/1</code></a>.</p>
  
   <p>In the next phase the code under test is run, and might or might not call
   the functions mocked.  The mock process checks that all functions programmed
   with <a href="#strict-4"><code>strict/4</code></a>, <a href="#strict-5"><code>strict/5</code></a> are called in the correct order,
   with the expected arguments and reacts in the way defined during the
   programming phase. If a mocked function is called although another function
   was expected, or if an expected function was called with different
   arguments, the mock process dies and prints a comprehensive error message
   before failing the test.</p>
  
   <p>To support mock invokations from multiple processes the strictness
   requirement can be reduced to calls belonging to the same group. <a href="#new_groups-2"><code>new_groups/2</code></a> creates a list of named groups, where calls belongig to
   different groups may occur in any order. A group is passed as mock reference
   (1st parameter) to <a href="#strict-5"><code>strict/5</code></a> or <a href="#strict-4"><code>strict/4</code></a>. Use <a href="#await-1"><code>await/1</code></a> with a list of groups to block the caller until all groups
   are finished, i.e. the expectations assigned to each group via <a href="#strict-5"><code>strict/5</code></a> were invoked. NOTE: It is prohibited to use the same expectations
   with different return values among a list groups created together.</p>
  
   <p>At the end of a unit test <a href="#await_expectations-1"><code>await_expectations/1</code></a> is called to
   await all invocations defined during the programming phase.</p>
  
   <p>An alternative to <a href="#await_expectations-1"><code>await_expectations/1</code></a> is <a href="#verify-1"><code>verify/1</code></a>. It is
   called to check for missing invocations at the end of the programming phase,
   if any expected invocations are missing at verify will throw an
   exception.</p>
  
   <p>When the mock process exits it tries hard to remove all modules, that
   were dynamically created and loaded during the programming phase.</p>
  
   <p>NOTE: This library works by purging the modules mocked and replacing them   
with dynamically created and compiled code, so be careful what you mock,   
i.e. it brings chaos to mock modules from kernel. This also implies, that   
tests that mock the same modules must be run sequentially.</p>
  
   Apart from that, it is very advisable to <b>only mock owned modules</b>
   anyway.
  
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-answer">answer()</a></h3>
<p><tt>answer() = {function, fun(([any()]) -&gt; any())} | {return, any()}</tt></p>


<h3 class="typedecl"><a name="type-args">args()</a></h3>
<p><tt>args() = [fun((any()) -&gt; true | false) | term()]</tt></p>


<h3 class="typedecl"><a name="type-group">group()</a></h3>
<p><tt>group() = {group, pid(), <a href="#type-group_tag">group_tag()</a>}</tt></p>


<h3 class="typedecl"><a name="type-group_tag">group_tag()</a></h3>
<p><tt>group_tag() = {term(), reference()}</tt></p>


<h3 class="typedecl"><a name="type-timeout_millis">timeout_millis()</a></h3>
<p><tt>timeout_millis() = non_neg_integer() | infinity</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#any-0">any/0</a></td><td>
  Utility function that can be used as a match function in an argument list
  to match any value.</td></tr>
<tr><td valign="top"><a href="#await-2">await/2</a></td><td>
  Block until a specific invokation defined via <a href="#strict-4"><code>strict/4</code></a> during the
  programming phase was made.</td></tr>
<tr><td valign="top"><a href="#await_expectations-1">await_expectations/1</a></td><td>
  Wait until all invokations defined during the programming phase were made.</td></tr>
<tr><td valign="top"><a href="#call_log-1">call_log/1</a></td><td>
  Retrieve a list of successfully mocked invokations, i.e.</td></tr>
<tr><td valign="top"><a href="#new-0">new/0</a></td><td>
  Spawn a linked mock process and return the pid.</td></tr>
<tr><td valign="top"><a href="#new_groups-2">new_groups/2</a></td><td>
  Create a group handle to assign mock expectation to.</td></tr>
<tr><td valign="top"><a href="#nothing-2">nothing/2</a></td><td>
  This is used to express the expectation that no function of a certain module
  is called.</td></tr>
<tr><td valign="top"><a href="#replay-1">replay/1</a></td><td>
  Finishes the programming phase and switches to the replay phase where the
  actual code under test may run and invoke the functions mocked.</td></tr>
<tr><td valign="top"><a href="#replay-2">replay/2</a></td><td>
  Finishes the programming phase and switches to the replay phase, expecting
  that invokations are recorded at least once every <code>InvokationTimeout</code> millis.</td></tr>
<tr><td valign="top"><a href="#strict-4">strict/4</a></td><td>  
Add an expectation during the programming phase for a specific function  
invokation.</td></tr>
<tr><td valign="top"><a href="#strict-5">strict/5</a></td><td>
  This function behaves like <a href="#strict-4"><code>strict/4</code></a>
  and additionally accepts a return value or an answer function.</td></tr>
<tr><td valign="top"><a href="#stub-4">stub/4</a></td><td>
  Defines a what happens when a function is called whithout recording any
  expectations.</td></tr>
<tr><td valign="top"><a href="#stub-5">stub/5</a></td><td>
  This is similar <code>stub/4</code> except that it, like
  <code>strict/5</code> allows the definition of a return value
  or an answer function.</td></tr>
<tr><td valign="top"><a href="#verify-1">verify/1</a></td><td>
  Finishes the replay phase.</td></tr>
<tr><td valign="top"><a href="#zelf-0">zelf/0</a></td><td>
  Utility function that can be used as a match function in an
  argument list to match <code>self()</code>, e.g.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="any-0">any/0</a></h3>
<div class="spec">
<p><tt>any() -&gt; fun((any()) -&gt; true)</tt><br></p>
</div><p>
  Utility function that can be used as a match function in an argument list
  to match any value.</p>

<h3 class="function"><a name="await-2">await/2</a></h3>
<div class="spec">
<p><tt>await(X1::<a href="#type-group">group()</a>, Handle::reference()) -&gt; {success, InvPid::pid(), Args::[term()]} | {error, term()}</tt><br></p>
</div><p>
  Block until a specific invokation defined via <a href="#strict-4"><code>strict/4</code></a> during the
  programming phase was made. <p>The handle for the specific invokation is the
  value returned by <a href="#strict-4"><code>strict/4</code></a>.</p> <p>The return value contains the
  parameters and the pid of the recorded invokation. This function maybe called
  anytime before or after the referenced invokation has actually
  happened.</p><p>If the handle is not valid, an error is returned.</p></p>

<h3 class="function"><a name="await_expectations-1">await_expectations/1</a></h3>
<div class="spec">
<p><tt>await_expectations(X1::<a href="#type-group">group()</a>) -&gt; ok</tt><br></p>
</div><p>
  Wait until all invokations defined during the programming phase were made.
  After this functions returns, the mock can be expected to exit and clean up
  all modules installed.</p>

<h3 class="function"><a name="call_log-1">call_log/1</a></h3>
<div class="spec">
<p><tt>call_log(X1::<a href="#type-group">group()</a>) -&gt; [{Mod::atom(), Func::atom(), Args::[term()], Answer::term()}]</tt><br></p>
</div><p>
  Retrieve a list of successfully mocked invokations, i.e. all calls that were
  accepted by the <code>em</code> process in the <code>replay</code> phase. Both strict and stub
  invokations are recorded.  NOTE: The Answer might as well be a function,
  depending on the <code>return</code> argument passed to <code>strict</code> or <code>stub</code>.</p>

<h3 class="function"><a name="new-0">new/0</a></h3>
<div class="spec">
<p><tt>new() -&gt; <a href="#type-group">group()</a></tt><br></p>
</div><p>
  Spawn a linked mock process and return the pid. <p>This is usually the
  first thing to do in each unit test. The resulting pid is used in the other
  functions below.</p> <p>NOTE: only a single mock proccess is required for a
  single unit test case. One mock process can mock an arbitrary number of
  different modules.</p> <p>When the mock process dies, all uploaded modules
  are purged from the code server, and all cover compiled modules are
  restored.</p> <p>When the process that started the mock exits, the mock
  automatically cleans up and exits.</p> <p>After new() the mock is in
  'programming' state.</p></p>

<h3 class="function"><a name="new_groups-2">new_groups/2</a></h3>
<div class="spec">
<p><tt>new_groups(X1::<a href="#type-group">group()</a>, GroupNames::[term()]) -&gt; [<a href="#type-group">group()</a>]</tt><br></p>
</div><p>
  Create a group handle to assign mock expectation to. The result can be passed
  to <a href="#strict-4"><code>strict/4</code></a> or <a href="#strict-5"><code>strict/5</code></a> and <a href="#await-2"><code>await/2</code></a>.</p>

<h3 class="function"><a name="nothing-2">nothing/2</a></h3>
<div class="spec">
<p><tt>nothing(X1::<a href="#type-group">group()</a>, Mod::atom()) -&gt; ok</tt><br></p>
</div><p>
  This is used to express the expectation that no function of a certain module
  is called. This will cause each function call on a module to throw an 'undef'
  exception.</p>

<h3 class="function"><a name="replay-1">replay/1</a></h3>
<div class="spec">
<p><tt>replay(G::<a href="#type-group">group()</a>) -&gt; ok</tt><br></p>
</div><p>
  Finishes the programming phase and switches to the replay phase where the
  actual code under test may run and invoke the functions mocked. This may
  be called only once, and only in the programming phase. This also loads
  (or replaces) the modules of the functions mocked.
  In the replay phase the code under test may call all mocked functions.
  If the application calls a mocked function with invalid arguments, or
  if the application calls a function not expected on a mocked module, the mock
  process dies and - if used in a typical edoc test suite - fails the test.</p>

<h3 class="function"><a name="replay-2">replay/2</a></h3>
<div class="spec">
<p><tt>replay(X1::<a href="#type-group">group()</a>, InvokationTimeout::<a href="#type-timeout_millis">timeout_millis()</a>) -&gt; ok</tt><br></p>
</div><p>
  Finishes the programming phase and switches to the replay phase, expecting
  that invokations are recorded at least once every <code>InvokationTimeout</code> millis.</p>
<p><b>See also:</b> <a href="#replay-1">replay/1</a>.</p>

<h3 class="function"><a name="strict-4">strict/4</a></h3>
<div class="spec">
<p><tt>strict(M::<a href="#type-group">group()</a>, Mod::atom(), Fun::atom(), Args::<a href="#type-args">args()</a>) -&gt; reference()</tt><br></p>
</div><p><p>  
Add an expectation during the programming phase for a specific function  
invokation.</p>
 
  <p>All expectations defined by 'strict' define an order in which the
  application must call the mocked functions, hence the name 'strict' as oposed
  to 'stub' (see below).</p>
 
  <p>The parameters are:
  <ul>
  <li><code>M</code> the mock pid, returned by <a href="#new-0"><code>new/0</code></a></li>
  <li><code>Mod</code> the module of the function to mock</li>
  <li><code>Fun</code> the name of the function to mock</li>
  <li><code>Args</code> a list of expected arguments.
  Each list element is either a value that will be matched to the actual value
  of the parameter at that position, or a predicate function which will be
  applied to the actual argument.</li>
  </ul></p>
 
  <p>This function returns a reference that identifies the expectation. This
  reference can be passed to <a href="#await-2"><code>await/2</code></a> which blocks until the expected
  invokation happens.</p>
 
  <p> The return value, that the application will get when calling the mocked
  function in the replay phase is simply the atom <code>ok</code>. This
  differentiates this function from <a href="#strict-5"><code>strict/5</code></a>, which allows the
  definition of a custom response function or a custom return value.  </p>
 
  NOTE: This function may only be called between <code>new/0</code> and <a href="#replay-1"><code>replay/1</code></a> - that is during the programming phase.
 </p>

<h3 class="function"><a name="strict-5">strict/5</a></h3>
<div class="spec">
<p><tt>strict(X1::<a href="#type-group">group()</a>, Mod::atom(), Fun::atom(), Args::<a href="#type-args">args()</a>, Answer::<a href="#type-answer">answer()</a>) -&gt; reference()</tt><br></p>
</div><p>
  This function behaves like <a href="#strict-4"><code>strict/4</code></a>
  and additionally accepts a return value or an answer function. That parameter
  <code>Answer</code> may be:
  <ul>
  <li><code>{return, SomeValue}</code> This causes the mocked function invocation to
  return the specified value.</li>
  <li><code>{function, fun(([Arg1, ... , ArgN]) -&gt; SomeValue)}</code> This defines
  a function to be called when the mocked invokation happens.
  That function is applied to all captured actual arguments.  For convenience these
  are passed as a list, so the user can simply write <code>fun(_) -&gt; ...</code>
  when the actual values are not needed.
  The function will be executed by the process that calls the mocked function, not
  by the mock process. Hence the function may access <code>self()</code> and may
  throw an exception, which will then correctly appear in the process under test,
  allowing unit testing of exception handling.
  Otherwise the value returned by the function is passed through as the value
  returned from the invocation.
  </li>
  </ul></p>

<h3 class="function"><a name="stub-4">stub/4</a></h3>
<div class="spec">
<p><tt>stub(M::<a href="#type-group">group()</a>, Mod::atom(), Fun::atom(), Args::<a href="#type-args">args()</a>) -&gt; ok</tt><br></p>
</div><p>
  Defines a what happens when a function is called whithout recording any
  expectations. The invocations defined by this function may happen in any order
  any number of times. The way, the invocation is defined is analog to</p>
<p><b>See also:</b> <a href="#strict-4"><code>strict/4</code></a>.</p>

<h3 class="function"><a name="stub-5">stub/5</a></h3>
<div class="spec">
<p><tt>stub(X1::<a href="#type-group">group()</a>, Mod::atom(), Fun::atom(), Args::<a href="#type-args">args()</a>, Answer::<a href="#type-answer">answer()</a>) -&gt; ok</tt><br></p>
</div><p>
  This is similar <code>stub/4</code> except that it, like
  <code>strict/5</code> allows the definition of a return value
  or an answer function.</p>
<p><b>See also:</b> <a href="#strict-5"><code>strict/5</code></a>, <a href="#stub-4"><code>stub/4</code></a>.</p>

<h3 class="function"><a name="verify-1">verify/1</a></h3>
<div class="spec">
<p><tt>verify(X1::<a href="#type-group">group()</a>) -&gt; ok</tt><br></p>
</div><p>
  Finishes the replay phase. If the code under test did not cause all expected
  invokations defined by <a href="#strict-4"><code>strict/4</code></a> or <a href="#strict-5"><code>strict/5</code></a>, the
  call will fail with <code>badmatch</code> with a comprehensive error message.
  Otherwise the mock process exits normally, returning <code>ok</code>.</p>

<h3 class="function"><a name="zelf-0">zelf/0</a></h3>
<div class="spec">
<p><tt>zelf() -&gt; atom()</tt><br></p>
</div><p>
  Utility function that can be used as a match function in an
  argument list to match <code>self()</code>, e.g. when it matches the pid of the
  process, that calls the funtion during the replay phase.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
